var log = require('osg-logger').of('cw:concurrent')
    , async = require('async')
    , redis = require('redis')
    , uuid = require('node-uuid')
    , redisReady = false
    , eventsQueue = {} //{ wid : value }
    ;

module.exports = function concurrent(config) {

    //disabled only if flag is exist and value is false))))
    var isDisable = !config.cloudWatch.enable
        , isConcurrentDisabled = config.cloudWatch.concurrent !== true
        ;
    //disable sending concurrent stats if it is disable for all metrics
    config.cloudWatch.concurrent = (isDisable || isConcurrentDisabled) ? false : true;
    if (config.cloudWatch.concurrent === false) {
        log.info('Send concurrent counter is disable from config');
    }

    var currentConcurent = {}
        , appName = config.app.name.toLowerCase()
        , appEnv = config.app.env.toLowerCase()
        , timer = config.cloudWatch.timer
        , model = config.cloudWatch.model
        , processId = uuid.v1()
        ;

    var redisClient;
    if (config.cloudWatch.concurrent && !config.cloudWatch.concurrentNew && config.redis) {
        redisClient = redis.createClient(config.redis.port, config.redis.hostname);
        redisClient.on('error', function (err) {
            log.error("redis  error:", err.stack || err);
        });
        redisClient.on('ready', function (err) {
            redisReady = true;
            async.forEachOf(eventsQueue
                , function (count, wId, callback) {
                    incrementBy(wId, count, callback);
                }
                , function (err) {
                    eventsQueue = {};
                }
                );
            log.info('redis connected');
        });

        timer.register(function () {
            Object.keys(currentConcurent).map(function (wId) {
                getConcurent(wId, function (err, count) {
                    if (err) {
                        log.error('concurrent error', err);
                        return;
                    }
                    model.push('concurrentCount:' + wId, {
                        type: 'concurrentCount',
                        host: config.cloudWatch.namespace,
                        worldId: wId,
                        count: count
                    });
                });

            });
        });
        var updateTime = config.cloudWatch.interval / 2;
        setInterval(function () {
            if (!redisReady) return;
            Object.keys(currentConcurent).map(function (wId) {
                updateExpirationTime(wId, function (err) {
                    if (err) {
                        return log.error("Update expiration time fail. wid = %s, err = ", wId, err);
                    }
                    log.debug("Update expiration time success. processId = %s, wid = %s", processId, wId);
                });
            });
        }, updateTime)
    }

    return {
        get: getConcurent
        , increment: increment
        , decrement: decrement
        , revert: revertKey
        , resetWorld: resetWorld
        , resetInstance: resetInstance
        , quit: quit
        , registerConcurrent: registerConcurrent 
    };
    
    function registerConcurrent(loopCbk) {
        timer.register(function () {
            loopCbk(sendConcurrent);
        });

        function sendConcurrent(params, options){
            model.push('concurrentCount:' + params.wId, {
                type: 'concurrentCount',
                host: config.cloudWatch.namespace,
                worldId: params.wId,
                count: params.count,
                instanceData: options.instanceData
            });
        }
    }
    
    function getConcurent(wId, callback) {
        if (!config.cloudWatch.concurrent) return suppressResult(callback, true, 'concurrent disabled');
        async.waterfall(
            [updateExpirationTime.bind(null, wId)
                , removeExpiredKeys.bind(null, wId)
                , getCounter
            ]
            , function (err, sum) {
                if (err) {
                    log.error("getWorldConcurrentUsers fail. err = ", err);
                }
                callback(null, sum);
            }
            );
        function getCounter(cbk) {
            var key = worldConcorentKey(wId);
            redisClient.hvals(key, function (err, values) {
                var sum = 0;
                if (err) {
                    cbk(err, sum);
                    return;
                }

                if (Array.isArray(values)) {
                    values.forEach(function (val) {
                        val = val * 1;
                        sum += isNaN(val) ? 0 : val;
                    })
                }

                log.debug("getWorldConcurrentUsers success. count = ", sum);
                cbk(null, sum);

            });
        }
    }

    function increment(wId, callback) {
        incrementBase(wId, 1, callback);
    }

    function incrementBy(wId, count, callback) {
        incrementBase(wId, count, callback);
    }

    function incrementBase(wId, count, callback) {
        if (!config.cloudWatch.concurrent) return suppressResult(callback, true, 'concurrent disabled');

        if (!redisReady) {
            addQueueIncrement(wId);
            return suppressResult(callback, true);
        }

        var key = worldConcorentKey(wId);
        redisClient.hincrby(key, processId, count, function (err, result) {
            if (err) {
                log.error('concurrent increment error', err);
                return suppressResult(callback, true, err);
            }

            if (!currentConcurent[wId]) currentConcurent[wId] = 0;
            currentConcurent[wId]++;

            updateExpirationTime(wId);
            suppressResult(callback, true);
        });
    }

    function decrement(wId, callback) {
        if (!config.cloudWatch.concurrent) return suppressResult(callback, true, 'concurrent disabled');
        if (!redisReady) {
            addQueueDecrement(wId);
            return suppressResult(callback, true);
        }
        var key = worldConcorentKey(wId);
        redisClient.hincrby(key, processId, -1, function (err, result) {
            if (err) {
                log.error('concurrent decrement error', err);
                return suppressResult(callback, true, err);
            }
            if (currentConcurent[wId]) currentConcurent[wId]--;

            updateExpirationTime(wId);
            suppressResult(callback, true);
        });
    }

    function revertKey(wId_, callback) {
        if (!config.cloudWatch.concurrent) return suppressResult(callback, true, 'concurrent disabled');
        if (typeof wId_ === 'function') {
            callback = wId_;
            async.forEachOf(
                currentConcurent,
                revert,
                suppressResult(callback, true)
                )
            ;
        } else {
            var value = currentConcurent[wId_];
            if (value) revert(value, wId_, callback);
            else suppressResult(callback, true, "worldId does not exist");
        }

        function revert(value, wId, callback) {
            var key = worldConcorentKey(wId);
            redisClient.get(key, function (err, result) {
                if (err) {
                    log.error('concurrent error', err);
                    return;
                }
                if (result) {
                    var amount = result - value;
                    //if (amount < 0) amount = 0; // TODO: handle minus results
                    redisClient.set(key, amount, suppressResult(callback, true));
                    delete currentConcurent[wId];
                }
            });
        }
    }


    function resetWorld(wId, callback) {
        if (!config.cloudWatch.concurrent) return suppressResult(callback, true, 'concurrent disabled');
        var key = worldConcorentKey(wId);
        var keyExpire = worldConcorentExpiresKey(wId);
        redisClient.del(key, suppressResult(callback));
        redisClient.del(keyExpire, suppressResult(callback));
    }

    function resetInstance(callback) {
        if (!config.cloudWatch.concurrent) return suppressResult(callback, true, 'concurrent disabled');

        Object.keys(currentConcurent).map(function (wId) {
            var key = worldConcorentKey(wId)
            redisClient.hset(key, processId, 0, function (err, result) {
                if (err) {
                    log.error('concurrent resetInstance error', err);
                    return suppressResult(callback, true, err);
                }
            });
        });

    }

    function quit() {
        if (!config.cloudWatch.concurrent) return;
        redisClient.quit();
    }

    function worldConcorentKey(wId) {
        return "map:concurrent:users:" + appName + ":" + appEnv + ":" + wId;
    }
    function worldConcorentExpiresKey(wId) {
        return "map:concurrent:expires:" + appName + ":" + appEnv + ":" + wId;
    }

    function suppressResult(callback, call, err) {
        if (typeof callback === 'function') return call ? callback(err) : callback;
        else return function () { }
    }

    function removeExpiredKeys(wid, callback) {
        var expKey = worldConcorentExpiresKey(wid)
            , expTime = config.cloudWatch.interval
            , timeNow = Date.now()
            , concorentKey
            ;
        redisClient.hgetall(expKey, function (err, timers) {
            if (err) {
                log.error("removeExpiredKeys fail. error ", err);
                return callback(err);
            }
            if (typeof timers != "object") {
                log.info("Map of expiration processes was not found in db");
                callback(null);
            }

            async.forEachOf(timers
                , function (time, pid, cbk) {
                    if (timeNow - time < expTime) {
                        log.debug("Expired time for process id i fresh, don't need to remove. processId = %s, time = %s", pid, time);
                        return cbk(null);
                    }
                    log.info("Process id is expired, remove counter. processId = %s, last update time = %s, time now = %s", pid, time, expTime);

                    concorentKey = worldConcorentKey(wid);

                    redisClient.hdel(concorentKey, pid, function (err) {
                        if (err) {
                            return cbk(err);
                        }
                        redisClient.hdel(expKey, pid, cbk);
                    });
                }
                , function (err) {
                    if (err) {
                        log.error("removeExpiredKeys fail. error ", err);
                        return callback(err);
                    }
                    callback(null);
                });
        });
    }

    function updateExpirationTime(wid, callback) {
        var key = worldConcorentExpiresKey(wid)
            ;
        callback = callback || function () { };
        redisClient.hset(key, processId, Date.now(), function (err, result) {
            if (err) {
                log.error("updateExpirationTime fail. error ", err);
                return callback(err);
            }
            callback(null);
        })
    }

    function addQueueIncrement(wId) {
        initQueueIfNeed(wId);
        eventsQueue[wId]++;
    }

    function addQueueDecrement(wId) {
        initQueueIfNeed(wId);
        eventsQueue[wId]--;
    }

    function initQueueIfNeed(wId) {
        if (!eventsQueue) {
            eventsQueue = {};
        }
        if (!eventsQueue[wId]) {
            eventsQueue[wId] = 0;
        }
    }
};
//log.debug('module loaded')