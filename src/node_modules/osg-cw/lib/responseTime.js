/* global process */
var log = require('osg-logger').of('cw:responseTime');

module.exports = function (options) {
    
    // this engine is set to 1 minute interval (1000 * 60)
    // TODO: implement option.interval and set 'setInterval' accordingly 
    
    var routes = {},
        samples = {},
        intervalCount = 0,
        model = options.model,
        timer = options.timer,
        metricData = []
        ;

    timer.register(function () {
        metricData.map(function (sample) {
            model.push('request:' + sample.type+ ':' + sample.route, sample);
        });
    });

    setInterval(function () {
        intervalCount++;
        Object.keys(routes).map(function (route) {
            var proc = routes[route];
            if (!samples[route]) samples[route] = [];
            samples[route].push(proc.reqs);
            proc.reqs = 0;
        });
        if (intervalCount >= 60) {
            intervalCount = 0;
            metricData.length = 0;
            Object.keys(routes).map(function (route) {
                var proc = routes[route];
                var sample = {};
                if (samples[route].length >= 1) {
                    sample.route = proc.route;
                    sample.host = proc.host;
                    sample.type = 'requestPerSec';
                    sample.count = samples[route].length;
                    sample.sum = 0;
                    samples[route].map(function (reqs) {
                        sample.sum += reqs;
                        if (sample.min === null || (sample.min > reqs)) sample.min = reqs;
                        if (sample.max === null || (sample.max < reqs)) sample.max = reqs;
                    });
                    samples[route].length = 0; // reset sample array
                    metricData.push(sample);
                }
                if (proc.ress >= 1) {
                    sample = {};
                    sample.route = proc.route;
                    sample.host = proc.host;
                    sample.type = 'responseTime';
                    sample.count = proc.ress;
                    sample.sum = proc.sum || 0;
                    sample.min = proc.min || 0;
                    sample.max = proc.max || 0;
                    metricData.push(sample);
                }
                proc.ress = 0;
                proc.sum = 0;
                proc.min = null;
                proc.max = null;
            });
        }
    }, 1000);

    function start(route, host) {
        var start = Date.now()
            , proc = routes[route] = routes[route] || { route: route, host: host, reqs: 0, ress: 0, sum: 0, min: null, max: null }
            ;
        proc.reqs++;
        return {
            end: function () {
                var duration = Date.now() - start;
                proc.ress++;
                proc.sum += duration;
                if (proc.min === null || (proc.min > duration)) proc.min = duration;
                if (proc.max === null || (proc.max < duration)) proc.max = duration;
            }
        }
    }
    
    return {
        start: start
    };
};
